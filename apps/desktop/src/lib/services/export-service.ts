import { invoke } from '@tauri-apps/api/core';
import { save as saveDialog } from '@tauri-apps/plugin-dialog';
import { toPng } from 'html-to-image';
import {
  getNodesBounds,
  getViewportForBounds,
} from '@xyflow/svelte';
import { diagram } from '$lib/stores/diagram.svelte';
import { project } from '$lib/stores/project.svelte';
import { registry } from '$lib/bootstrap';
import type { ResourceTypeId } from '@terrastudio/types';

/**
 * Get the .svelte-flow viewport element from the DOM.
 */
function getFlowElement(): HTMLElement | null {
  return document.querySelector('.svelte-flow') as HTMLElement | null;
}

/**
 * Export the diagram as a PNG file.
 * Shows a save dialog for the user to pick the destination.
 */
export async function exportPNG(): Promise<void> {
  const dataUrl = await generatePngDataUrl();
  if (!dataUrl) return;

  const path = await saveDialog({
    title: 'Export Diagram as PNG',
    defaultPath: `${project.name || 'diagram'}.png`,
    filters: [{ name: 'PNG Image', extensions: ['png'] }],
  });

  if (!path) return;

  // Convert data URL to bytes
  const base64 = dataUrl.split(',')[1];
  const bytes = Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));

  await invoke('write_export_file', {
    path,
    data: Array.from(bytes),
  });
}

/**
 * Copy the diagram as a PNG to the clipboard.
 */
export async function copyDiagramToClipboard(): Promise<void> {
  const dataUrl = await generatePngDataUrl();
  if (!dataUrl) return;

  // Convert data URL to blob and write to clipboard
  const response = await fetch(dataUrl);
  const blob = await response.blob();
  await navigator.clipboard.write([
    new ClipboardItem({ 'image/png': blob }),
  ]);
}

/**
 * Generate a PNG data URL from the current diagram.
 */
async function generatePngDataUrl(): Promise<string | null> {
  const flowEl = getFlowElement();
  if (!flowEl || diagram.nodes.length === 0) return null;

  const nodesBounds = getNodesBounds(diagram.nodes);
  const padding = 50;
  const imageWidth = nodesBounds.width + padding * 2;
  const imageHeight = nodesBounds.height + padding * 2;

  const viewport = getViewportForBounds(
    nodesBounds,
    imageWidth,
    imageHeight,
    0.5,
    2,
    padding,
  );

  return toPng(flowEl, {
    backgroundColor: '#1a1a2e',
    width: imageWidth,
    height: imageHeight,
    style: {
      width: `${imageWidth}px`,
      height: `${imageHeight}px`,
      transform: `translate(${viewport.x}px, ${viewport.y}px) scale(${viewport.zoom})`,
    },
  });
}

/**
 * Export architecture documentation as Markdown.
 */
export async function exportDocumentation(): Promise<void> {
  const markdown = generateDocumentation();

  const path = await saveDialog({
    title: 'Export Architecture Documentation',
    defaultPath: `${project.name || 'architecture'}.md`,
    filters: [{ name: 'Markdown', extensions: ['md'] }],
  });

  if (!path) return;

  const encoder = new TextEncoder();
  const bytes = encoder.encode(markdown);

  await invoke('write_export_file', {
    path,
    data: Array.from(bytes),
  });
}

/**
 * Generate Markdown architecture documentation from the current diagram.
 */
function generateDocumentation(): string {
  const lines: string[] = [];
  const projectName = project.name || 'TerraStudio Project';

  // Title
  lines.push(`# ${projectName} â€” Architecture Documentation`);
  lines.push('');
  lines.push(`> Auto-generated by TerraStudio on ${new Date().toLocaleDateString()}`);
  lines.push('');

  // Resource Inventory
  lines.push('## Resource Inventory');
  lines.push('');

  if (diagram.nodes.length === 0) {
    lines.push('*No resources in diagram.*');
    lines.push('');
  } else {
    lines.push('| Resource | Type | Terraform Name | Provider Type | Status |');
    lines.push('|----------|------|----------------|---------------|--------|');

    for (const node of diagram.nodes) {
      const typeId = node.data.typeId as ResourceTypeId;
      const schema = registry.getResourceSchema(typeId);
      const displayType = schema?.displayName ?? typeId;
      const tfName = node.data.terraformName;
      const tfType = schema?.terraformType ?? 'â€”';
      const status = node.data.deploymentStatus ?? 'pending';
      const statusIcon = status === 'created' ? 'deployed' : 'pending';

      lines.push(`| ${node.data.label} | ${displayType} | \`${tfName}\` | \`${tfType}\` | ${statusIcon} |`);
    }
    lines.push('');
  }

  // Hierarchy
  const containers = diagram.nodes.filter((n) => {
    const schema = registry.getResourceSchema(n.data.typeId as ResourceTypeId);
    return schema?.isContainer;
  });

  if (containers.length > 0) {
    lines.push('## Resource Hierarchy');
    lines.push('');

    // Build parent->children map
    const childrenMap = new Map<string | undefined, typeof diagram.nodes>();
    for (const node of diagram.nodes) {
      const parentId = node.parentId as string | undefined;
      if (!childrenMap.has(parentId)) childrenMap.set(parentId, []);
      childrenMap.get(parentId)!.push(node);
    }

    function renderTree(parentId: string | undefined, indent: string) {
      const children = childrenMap.get(parentId) ?? [];
      for (const child of children) {
        const schema = registry.getResourceSchema(child.data.typeId as ResourceTypeId);
        const icon = schema?.isContainer ? 'ðŸ“' : 'ðŸ“„';
        lines.push(`${indent}- ${icon} **${child.data.label}** (${schema?.displayName ?? child.data.typeId})`);
        renderTree(child.id, indent + '  ');
      }
    }

    renderTree(undefined, '');
    lines.push('');
  }

  // Dependency Graph (Mermaid)
  if (diagram.edges.length > 0) {
    lines.push('## Dependency Graph');
    lines.push('');
    lines.push('```mermaid');
    lines.push('graph TD');

    // Node definitions
    for (const node of diagram.nodes) {
      const label = node.data.label.replace(/"/g, "'");
      lines.push(`    ${node.id}["${label}"]`);
    }

    // Edges
    for (const edge of diagram.edges) {
      lines.push(`    ${edge.source} --> ${edge.target}`);
    }

    lines.push('```');
    lines.push('');
  }

  // Key Properties
  lines.push('## Resource Details');
  lines.push('');

  for (const node of diagram.nodes) {
    const typeId = node.data.typeId as ResourceTypeId;
    const schema = registry.getResourceSchema(typeId);
    lines.push(`### ${node.data.label}`);
    lines.push('');
    lines.push(`- **Type**: ${schema?.displayName ?? typeId}`);
    lines.push(`- **Terraform**: \`${schema?.terraformType}.${node.data.terraformName}\``);

    // Show non-default properties
    if (schema?.properties) {
      const props = node.data.properties;
      const nonDefaultProps = schema.properties.filter((p) => {
        const val = props[p.key];
        return val !== undefined && val !== '' && val !== p.defaultValue;
      });

      if (nonDefaultProps.length > 0) {
        lines.push('- **Properties**:');
        for (const prop of nonDefaultProps) {
          const val = props[prop.key];
          const display = typeof val === 'object' ? JSON.stringify(val) : String(val);
          lines.push(`  - ${prop.label}: \`${display}\``);
        }
      }
    }

    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push('*Generated by [TerraStudio](https://github.com/afroze9/terrastudio)*');

  return lines.join('\n');
}
